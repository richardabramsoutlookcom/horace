---
phase: 01-visual-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - main.js
autonomous: false

must_haves:
  truths:
    - "Color areas show visible 8x8 attribute block constraints"
    - "Each 8x8 block contains at most 2 colors (ink + paper)"
    - "Color clash effect is visible at block boundaries"
  artifacts:
    - path: "main.js"
      provides: "Attribute block system"
      contains: "attrBuffer"
    - path: "main.js"
      provides: "Attribute helper functions"
      exports: ["setAttr", "getAttr", "clearAttrs"]
  key_links:
    - from: "drawRoad/drawSki"
      to: "attrBuffer"
      via: "setAttr calls"
      pattern: "setAttr\\("
    - from: "attrBuffer"
      to: "32x24 grid"
      via: "block index calculation"
      pattern: "Math\\.floor.*\\/ 8"
---

<objective>
Implement ZX Spectrum attribute block system with color clash constraints.

Purpose: The ZX Spectrum's distinctive "color clash" comes from its attribute system where each 8×8 pixel block can only display 2 colors (ink and paper). This creates the characteristic visual artifacts that define the Spectrum's look.

Output: Rendering respects 8×8 attribute blocks, with optional debug visualization to verify constraints are working.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-visual-foundation/01-01-SUMMARY.md

@main.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement attribute buffer and helper functions</name>
  <files>main.js</files>
  <action>
    1. Create attribute buffer after ZX_PALETTE definition:
       ```javascript
       // ZX Spectrum attribute system: 32×24 blocks of 8×8 pixels
       // Each block stores: { ink: colorName, paper: colorName }
       const ATTR_COLS = 32;  // 256 / 8
       const ATTR_ROWS = 24;  // 192 / 8
       let attrBuffer = [];

       function clearAttrs(paperColor = 'BLACK') {
         attrBuffer = [];
         for (let i = 0; i < ATTR_ROWS * ATTR_COLS; i++) {
           attrBuffer[i] = { ink: null, paper: paperColor };
         }
       }

       function getAttrIndex(x, y) {
         const col = Math.floor(x / 8);
         const row = Math.floor(y / 8);
         if (col < 0 || col >= ATTR_COLS || row < 0 || row >= ATTR_ROWS) return -1;
         return row * ATTR_COLS + col;
       }

       function setAttr(x, y, ink, paper = null) {
         const idx = getAttrIndex(x, y);
         if (idx < 0) return;
         if (ink) attrBuffer[idx].ink = ink;
         if (paper) attrBuffer[idx].paper = paper;
       }

       function getAttr(x, y) {
         const idx = getAttrIndex(x, y);
         if (idx < 0) return { ink: 'WHITE', paper: 'BLACK' };
         return attrBuffer[idx];
       }

       // Get valid color for a pixel position based on attribute
       function getValidColor(x, y, desiredColor) {
         const attr = getAttr(x, y);
         // If this color is already ink or paper, use it
         if (desiredColor === attr.ink || desiredColor === attr.paper) {
           return ZX_PALETTE[desiredColor];
         }
         // If ink is not set, set it
         if (!attr.ink) {
           setAttr(x, y, desiredColor);
           return ZX_PALETTE[desiredColor];
         }
         // If paper matches, return ink (color clash!)
         if (attr.paper === desiredColor) {
           return ZX_PALETTE[attr.ink];
         }
         // Otherwise return ink (color clash - can only have 2 colors)
         return ZX_PALETTE[attr.ink];
       }
       ```

    2. Add debug visualization toggle:
       ```javascript
       let showAttrGrid = false; // Toggle with 'G' key for debug

       function drawAttrGrid() {
         if (!showAttrGrid) return;
         ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
         ctx.lineWidth = 1;
         for (let x = 0; x <= 256; x += 8) {
           ctx.beginPath();
           ctx.moveTo(x, 0);
           ctx.lineTo(x, 192);
           ctx.stroke();
         }
         for (let y = 0; y <= 192; y += 8) {
           ctx.beginPath();
           ctx.moveTo(0, y);
           ctx.lineTo(256, y);
           ctx.stroke();
         }
       }
       ```

    3. Add keyboard handler for debug toggle (in bindInput):
       - 'G' key toggles showAttrGrid

    4. Initialize attribute buffer at game start (call clearAttrs() in start())
  </action>
  <verify>
    - attrBuffer is 768 elements (32×24)
    - getAttrIndex(0, 0) returns 0
    - getAttrIndex(255, 191) returns 767
    - Press 'G' shows magenta grid overlay
  </verify>
  <done>
    - Attribute buffer created and initialized
    - Helper functions work correctly
    - Debug grid toggles with 'G' key
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate attribute system with drawing code</name>
  <files>main.js</files>
  <action>
    1. Update draw() to clear attributes at start of each frame:
       ```javascript
       function draw(dt) {
         // Clear attribute buffer for new frame
         clearAttrs(state.mode === MODE.SKI ? 'BRIGHT_WHITE' : 'BLACK');
         // ... rest of draw code
       }
       ```

    2. For this initial implementation, the attribute system tracks colors but doesn't strictly enforce yet. The visual effect comes from:
       - Using ZX Spectrum palette (already done in Plan 01)
       - Designing sprites/graphics to work within 8×8 blocks
       - Showing the grid to visualize block boundaries

    3. Add attribute setting calls in draw functions to track what colors are used:
       - In drawRoad(): set attrs when drawing background regions, shop, road
       - In drawSki(): set attrs for snow, gates, obstacles
       - In drawHorace(): set attrs for character

       Example in drawRoad():
       ```javascript
       // Background
       ctx.fillStyle = ZX_PALETTE.BLACK;
       ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);
       // Track in attribute system
       for (let y = 0; y < LOGICAL_H; y += 8) {
         for (let x = 0; x < LOGICAL_W; x += 8) {
           setAttr(x, y, null, 'BLACK');
         }
       }
       ```

    4. Call drawAttrGrid() at end of draw() (after all other drawing)

    Note: Full color clash enforcement (where trying to draw a 3rd color in a block fails) is tracked but not strictly enforced in this implementation. The constraint awareness is what matters - future sprite design will respect the blocks.
  </action>
  <verify>
    - clearAttrs() called at start of each frame
    - Drawing functions set attributes appropriately
    - Debug grid shows 8×8 block structure
    - Colors stay within palette (from Plan 01)
  </verify>
  <done>
    - Attribute system integrated with rendering
    - Each frame starts with fresh attribute buffer
    - Block boundaries visible in debug mode
    - Foundation laid for strict enforcement if needed
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>ZX Spectrum attribute block system with debug visualization</what-built>
  <how-to-verify>
    1. Open index.html in browser
    2. Start the game (click keyboard or swipe)
    3. Press 'G' to toggle attribute grid overlay
    4. Verify: Magenta grid shows 8×8 pixel blocks
    5. Verify: Grid is 32 columns × 24 rows
    6. Verify: Game graphics align reasonably with grid
    7. Play through ROAD mode and SKI mode
    8. Verify: No console errors
    9. Verify: Colors are all from ZX Spectrum palette (no grays, all saturated)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any visual issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] attrBuffer array exists with 768 elements
- [ ] clearAttrs(), setAttr(), getAttr() functions work
- [ ] Debug grid toggles with 'G' key
- [ ] Grid shows 32×24 blocks (8×8 pixels each)
- [ ] Both ROAD and SKI modes render with attribute tracking
- [ ] Human verified visual appearance
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Attribute block system functional
- Debug grid visible and correctly sized
- Human approved visual appearance
</success_criteria>

<output>
After completion, create `.planning/phases/01-visual-foundation/01-02-SUMMARY.md`
</output>
